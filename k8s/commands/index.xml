<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Commands on SL Notebook</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/</link><description>Recent content in Commands on SL Notebook</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 24 Apr 2025 11:14:18 +0200</lastBuildDate><atom:link href="https://slnotes.blog.castrillon.ch/k8s/commands/index.xml" rel="self" type="application/rss+xml"/><item><title>DaemonSet</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/daemonset/</link><pubDate>Thu, 24 Apr 2025 11:14:18 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/daemonset/</guid><description>Get daemon sets kubectl get daemonsets</description></item><item><title>Nodes</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/nodes/</link><pubDate>Mon, 21 Apr 2025 16:50:13 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/nodes/</guid><description>Add labels to a node kubectl label nodes node_name key=value</description></item><item><title>Namespaces</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/namespaces/</link><pubDate>Sat, 12 Apr 2025 15:27:54 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/namespaces/</guid><description>Imperative Create namespace kubectl create namespace dev-ns</description></item><item><title>Services</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/services/</link><pubDate>Sat, 12 Apr 2025 15:15:17 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/services/</guid><description>Imperative Create service for an existing pod kubectl expose pod pod_name --port=port --name service_name # By default, ClusterIP kubectl expose pod pod_name --port=port --target-port=tp --name service_name kubectl expose pod pod_name --type=NodePort --port=port --name service_name # Port on node will be random, if this is not ok, it has to be done with a file kubectl create service clusterip service_name --tcp=port:tp # Will not use the labels on a pod as selectors, but will search for labels app=service_nameGet service kubectl get svcCreate service YAML File kubectl expose pod pod_name --port=port --name service_name --dry-run=client -o yaml kubectl create service clusterip service_name --tcp=port:tp --dry-run=client -o yaml</description></item><item><title>ReplicaSets</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/replicasets/</link><pubDate>Sat, 12 Apr 2025 14:28:14 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/replicasets/</guid><description>Get Replica Sets kubectl get replicaset kubectl get rsGet single replica set kubectl describe replicaset rs_nameImperative Scale replica set ad-hoc kubectl scale --replicas=6 replicaset rs_nameImperative Destroy replica set kubectl delete replicaset rs_name</description></item><item><title>Pods</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/pods/</link><pubDate>Sat, 12 Apr 2025 14:28:04 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/pods/</guid><description>Get all pods kubectl get pods kubectl get pods -o wide # Adds more info like ipGet single pod kubectl describe pod pod_nameGet pods based on selector kubectl get pods --selector key=valueGenerate POD Manifest YAML file kubectl run pod_name --image=img --dry-run=client -o yamlImperative Run pod ad-hoc kubectl run pod_name --image image_name kubectl run pod_name --image=image_name --labels=&amp;#34;k1=v1,k2=v2&amp;#34; kubectl run pod_name --image=image_name --port=80 --expose=true # Create a service directlyImperative Destroy pod kubectl delete pod pod_name</description></item><item><title>Deployments</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/deployments/</link><pubDate>Sat, 12 Apr 2025 14:27:41 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/deployments/</guid><description>Imperative Create Deployment kubectl create deployment --image=img d_name kubectl create deployment --image=img d_name --replicas=4 # Create with +1 replicasGenerate Deployment YAML file kubectl create deployment --image=img --dry-run=client -o yamlImperative Scale deployment kubectl scale deployment d_name --replicas=4See rollout status (following logs) kubectl rollout status deployments/d_nameSee revision history kubectl rollout history deployments/d_nameImperative Rollback to previous revision kubectl rollout undo deployments/d_nameImperative Change deployment image ad-hoc kubectl set image deployments/d_name cont_name=image</description></item><item><title>General</title><link>https://slnotes.blog.castrillon.ch/k8s/commands/general/</link><pubDate>Sat, 12 Apr 2025 13:27:59 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/commands/general/</guid><description>Imperative vs Declarative management commands In K8s, there is three paradigms to manage general resources:
Imperative approach with commands: Using kubectl commands like run, create, edit, expose, scale to perform operations Imperative approach using a configuration file: Using kubectl commands like create, replace and delete with -f options Declarative approach using a configuration file: Using kubectl apply -f kubectl apply In general, due to best practices like maintainability, repeatability and documentation, the declarative approach (Using kubectl apply is preferred).</description></item></channel></rss>