<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Commands on SL Notebook</title><link>https://juan-castrillon.github.io/sl-notes-v2/k8s/commands/index.html</link><description>Recent content in Commands on SL Notebook</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 12 Apr 2025 13:27:59 +0200</lastBuildDate><atom:link href="https://juan-castrillon.github.io/sl-notes-v2/k8s/commands/index.xml" rel="self" type="application/rss+xml"/><item><title>General</title><link>https://juan-castrillon.github.io/sl-notes-v2/k8s/commands/general/index.html</link><pubDate>Sat, 12 Apr 2025 13:27:59 +0200</pubDate><guid>https://juan-castrillon.github.io/sl-notes-v2/k8s/commands/general/index.html</guid><description>Imperative vs Declarative management commands In K8s, there is three paradigms to manage general resources:
Imperative approach with commands: Using kubectl commands like run, create, edit, expose, scale to perform operations Imperative approach using a configuration file: Using kubectl commands like create, replace and delete with -f options Declarative approach using a configuration file: Using kubectl apply -f kubectl apply In general, due to best practices like maintainability, repeatability and documentation, the declarative approach (Using kubectl apply is preferred).</description></item></channel></rss>