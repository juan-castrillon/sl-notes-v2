<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AccessControl on SL Notebook</title><link>https://slnotes.blog.castrillon.ch/k8s/accesscontrol/</link><description>Recent content in AccessControl on SL Notebook</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 24 Apr 2025 20:26:52 +0200</lastBuildDate><atom:link href="https://slnotes.blog.castrillon.ch/k8s/accesscontrol/index.xml" rel="self" type="application/rss+xml"/><item><title>Admission Controllers</title><link>https://slnotes.blog.castrillon.ch/k8s/accesscontrol/admission/</link><pubDate>Thu, 24 Apr 2025 20:26:52 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/k8s/accesscontrol/admission/</guid><description>Admission controllers are pieces of code that run inside the kube-api-server and process requests to modify (create, edit, etc) resources after they have been authenticated and authorized, but before they go to scheduling.
They can be used both to verify configuration (Validating controllers) or take action (Mutating controllers). Some examples include:
Deny a request that aims to create a pod in non-existent namespace (NamespaceLifecycle controller, type validating) If a request aims to create a pod in a non-existent namespace, first create the namespace (NamespaceAutoProvision controller, mutating type) Order of execution Mutating controllers always run first, so that their result can be validated.</description></item></channel></rss>