<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System on SL Notebook</title><link>https://slnotes.blog.castrillon.ch/linux/system/</link><description>Recent content in System on SL Notebook</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 12 Aug 2025 14:57:21 +0200</lastBuildDate><atom:link href="https://slnotes.blog.castrillon.ch/linux/system/index.xml" rel="self" type="application/rss+xml"/><item><title>System Startup</title><link>https://slnotes.blog.castrillon.ch/linux/system/system-startup/</link><pubDate>Wed, 04 Jan 2023 22:46:37 +0100</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/system-startup/</guid><description>The boot process In linux, the boot process occurs when initiating the system. It goes from the moment the computer is powered on until the UI is fully operational and ready.
This is a sequential Process
1. BIOS Basic Input Output System Initializes the hardware (including monitor and keyboard) Tests the main memory (Power On Self Test) Normally installed in a ROM in the motherboard 2. Boot Loader First Stage: In Old systems: The BIOS looks for executable boot code in a certain part of the disk (Master Boot Record (MBR)).</description></item><item><title>Service Management</title><link>https://slnotes.blog.castrillon.ch/linux/system/services/</link><pubDate>Tue, 12 Aug 2025 14:57:21 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/services/</guid><description>systemd is the default init system and service manager in many modern Linux distributions. It is responsible for:
Initializing the system at boot. Managing system and user services. Handling system states and targets (boot modes) See System startup. Logging via the system journal. Unlike traditional init systems, systemd starts services in parallel, which can speed up boot times. It manages units, which are objects that describe system resources and how they should be handled.</description></item><item><title>Networking</title><link>https://slnotes.blog.castrillon.ch/linux/system/networking/</link><pubDate>Mon, 11 Aug 2025 16:36:48 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/networking/</guid><description>In computer systems, a network is a group of devices (also known as nodes) connected together. Nodes in a network can communicate and exchange information with each others
Every device on a network must have a unique address, called an IP address, which is used to send and receive data.
There are two primary types of IP addresses:
IPv4 (e.g. 192.168.0.1) â€” 32-bit addresses, widely used but limited in quantity. They are composed by 4 octets (8 bits) IPv6 (e.</description></item><item><title>Files</title><link>https://slnotes.blog.castrillon.ch/linux/system/files/</link><pubDate>Sat, 31 May 2025 20:22:40 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/files/</guid><description/></item><item><title>Devices</title><link>https://slnotes.blog.castrillon.ch/linux/system/devices/</link><pubDate>Sat, 31 May 2025 20:22:03 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/devices/</guid><description>Linux interacts with attached hardware mounting it as device file (See file types)
Device creation process When a new device is attached, the corresponding device driver in the Linux kernel identifies the state change and generates a uEvent. This event is forwarded to the user-space device manager daemon, udev, which then dynamically creates a device file under the /dev filesystem for the new device.
Accessing devices information Accessing logs The kernel logs can be inspected for logs about device attachment, errors, etc.</description></item><item><title>Kernel</title><link>https://slnotes.blog.castrillon.ch/linux/system/kernel/</link><pubDate>Sat, 31 May 2025 19:52:30 +0200</pubDate><guid>https://slnotes.blog.castrillon.ch/linux/system/kernel/</guid><description>The linux kernel is the main component in all linux distributions. It serves as the core interface between computer hardware and application processes, allowing the applications to talk to the underlying physical devices.
Modules The kernel is a monolithic (handling most tasks on itself) software, but it is extensible using modules
The kernel is responsible for many critical tasks like:
Memory Management It keeps track of the memory used/free and which process are using/needing memory Divides the memory into two spaces Kernel space: Processes that the kernel starts, and are needed for the system to run, these have unrestricted access to resources User space: All other processes, access to resources is controlled and limited to certain extend.</description></item></channel></rss>