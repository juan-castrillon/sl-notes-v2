var relearn_search_index=[{content:`Welcome! Welcome to my personal collection of notes and summaries on tech related topics! this is just a big cheat sheet where I store all the things that I learn in courses, certifications, on classes and on jobs in order for me to have easy access from anywhere.
Here you will find a wealth of information on various tech subjects, including programming languages, DevOps Tools, cloud, software engineering, and more. I have organized my notes by topic and subject, making it easy for you (but most probably me) to find the information needed.
If you are someone that is not me, I hope you find my notes to be helpful and informative.
Thank you for visiting my site, and happy learning!
`,description:"",tags:null,title:"Notes",uri:"/index.html"},{content:`Package managers The process of installing software on Linux can vary depending on the distribution you are using. Here is a general overview of the common methods used to install software on different Linux distributions:
Debian and Ubuntu: Software is typically installed using the apt package manager. Low level manager is normally dpkg Red Hat and Fedora: Software is typically installed using the yum package manager. Low level manager is normally rpm SUSE Family: Software is typically installed using the zypper package manager. Low level manager is normally rpm Other distributions: Some other Linux distributions, such as Slackware, use their own package management systems. You can refer to the distribution’s documentation for information on how to install software. Each package contains the files and other instructions needed to make one software component work well and cooperate with the other components that comprise the entire system.
All linux distributions have a low level and a high level package manager:
The low level, is in charge of installing single packages correctly. The high level usually calls the low level one and additionally, is in charge of resolving dependencies. Other ways of installing It’s also worth noting that there are other ways to install software on Linux, such as downloading binaries, compiling from source code, using flatpak, or using snap which is increasingly popular, but package managers are the most common and recommended method.
Common operations Operation RH Family Debian Family Install package rpm -i foo.rpm dpkg --install foo.deb Install package, dependencies yum install foo apt-get install foo or apt install foo Remove package rpm -e foo.rpm dpkg --remove foo.deb Remove package, dependencies yum remove foo apt-get remove foo or apt remove foo Remove package, deps, and config apt-get remove --purge foo or apt purge foo Remove “left-behind” packages yum autoremove apt-get autoremove or apt autoremove Update package rpm -U foo.rpm dpkg --install foo.deb Update package, dependencies yum update foo apt-get install foo Update entire system yum update apt-get dist-upgrade Show all installed packages rpm -qa or yum list installed dpkg --list or apt list --installed Get information on package rpm -qil foo dpkg --listfiles foo Show packages named foo yum list "foo" apt-cache search foo or apt search foo Show all available packages yum list apt-cache dumpavail foo What package is file part of? rpm -qf file dpkg --search file Debian-based distributions APT and APT-GET apt and apt-get are both package management tools for Debian and Ubuntu-based Linux distributions but apt is a more user-friendly tool, abstracting some of the functionality from other commands. apt-get is considered to be more powerful and flexible, and mostly used in automation for the -y option for example.
Repositories apt (or apt-get) stores a list of repositories or software channels in the file /etc/apt/sources.list and in any file with the suffix .list under the directory /etc/apt/sources.list.d/
A software repository is a collection of software packages that can be installed on the system. These packages are organized and managed by Ubuntu developers and are easily accessible to users via the apt package manager.
By editing these files from the command line, we can add, remove, or temporarily disable software repositories.
Format A typical line on the file looks like this:
deb http://ch.archive.ubuntu.com/ubuntu/ saucy main restricted deb: These repositories contain binaries or precompiled packages. These repositories are required for most users. deb-src: These repositories contain the source code of the packages. Useful for developers. http://archive.ubuntu.com/ubuntu: The URI (Uniform Resource Identifier), in this case a location on the internet. saucy is the release name or version of the distribution (found with lsb_release -sc). main \u0026 restricted are the section names or components. There can be several section names, separated by spaces. Adding new repositories Adding a new line with the above format will add a new repository. To “load” them is important to retrieve the updated package list with
sudo apt-get update PPA Repositories Adding Launchpad PPA (Personal Package Archive) is possible conveniently via the command add-apt-repository in Ubuntu or addrepo on Debian. It looks like: sudo add-apt-repository ppa:\u003crepository-name\u003e
`,description:"",tags:null,title:"Installing Software",uri:"/linux/using-a-linux-system/installing-software/index.html"},{content:`The boot process In linux, the boot process occurs when initiating the system. It goes from the moment the computer is powered on until the UI is fully operational and ready.
This is a sequential Process
1. BIOS Basic Input Output System Initializes the hardware (including monitor and keyboard) Tests the main memory Normally installed in a ROM in the motherboard 2. Boot Loader \u0026 Kernel First Stage: Master Boot Record (MBR) examines the partition table and finds a bootable partition. Also finds a second-stage bootloader (e.g. GRUB) and loads in into RAM Second Stage: Programs like GRUB allow to choose the OS. Once decided, it loads the kernel and the initial RAM disks (in RAM) and passes control to the kernel. (Kernel first job is to decompress itself) When the kernel is loaded in RAM, it initializes and configures the computer’s memory and also configures all the hardware attached to the system. Second stage bootloaders are located in /boot Some second-stage bootloaders are GRUB (for GRand Unified Boot loader), ISOLINUX (for booting from removable media), and DAS U-Boot (for booting on embedded devices/appliances) 3. Initial RAM Disk initramfs Contains programs and binary files that perform all actions needed to mount the proper root filesystem After the root filesystem has been found, it is checked for errors and mounted. At boot time, the boot loader loads the kernel and the initramfs image into memory and starts the kernel. The kernel checks for the presence of the initramfs and, if found, mounts it as / and runs /sbin/init. 4. /sbin/init init handles the mounting and pivoting over to the final real root filesystem. Normally a shell script. Is the parent process of nearly all processes Near the end of the boot process, init starts a number of text-mode login prompts. In case of an OS with a GUI, then this is loaded and displayed instead /sbin/init and Services Apart from being the initial process, the init script is also responsible for:
Keeping the system running (Managing other processes, cleaning up after them, etc) Shut down cleanly Methods for this startup are systemd and Upstart
systemd Current systems use systemd instead of init because it simplifies the init process and makes it faster (parallel service execution instead of sequential) Complicated startup shell scripts are replaced with simpler configuration files /sbin/init now just points to /lib/systemd/systemd; Some commands are:
Starting, stopping, restarting a service (using nfs as an example) on a currently running system:
sudo systemctl start|stop|restart nfs.service Enabling or disabling a system service from starting up at system boot:
sudo systemctl enable|disable nfs.service `,description:"",tags:null,title:"System Startup",uri:"/linux/system/system-startup/index.html"},{content:`The Linux kernel is the core of the operating system. A full Linux distribution consists of the kernel plus a number of other software tools for file-related operations, user management, and software package management
Distribution Families There are more than 200 distributions. The most commonly used can be categorized in three families:
Red Hat Family Systems (including CentOS and Fedora) SUSE Family Systems (including openSUSE) Debian Family Systems (including Ubuntu and Linux Mint). Red Hat Some of the key facts about the Red Hat distribution family are:
Fedora serves as an upstream testing platform for RHEL. CentOS is a close clone of RHEL, while Oracle Linux is mostly a copy with some changes (in fact, CentOS has been part of Red Hat since 2014). CentOS 8 has reached end of life while CentOS 7 will do it in 2024 A heavily patched version 3.10 kernel is used in RHEL/CentOS 7, while version 4.18 is used in RHEL/CentOS 8. It supports hardware platforms such as Intel x86, Arm, Itanium, PowerPC, and IBM System z. It uses the yum and dnf RPM-based yum package managers to install, update, and remove packages in the system. RHEL is widely used by enterprises which host their own systems. SUSE Some of the key facts about the SUSE family are listed below:
SUSE Linux Enterprise Server (SLES) is upstream for openSUSE. Kernel version 4.12 is used in openSUSE Leap 15. It uses the RPM-based zypper package manager to install, update, and remove packages in the system. It includes the YaST (Yet Another Setup Tool) application for system administration purposes. SLES is widely used in retail and many other sectors. Debian Some key facts about the Debian family are listed below:
The Debian family is upstream for Ubuntu, and Ubuntu is upstream for Linux Mint and others. Kernel version 4.15 is used in Ubuntu 18.04 LTS. It uses the DPKG-based APT package manager (using apt, apt-get, apt-cache, etc.) to install, update, and remove packages in the system. Ubuntu has been widely used for cloud deployments. While Ubuntu is built on top of Debian and is GNOME-based under the hood, it differs visually from the interface on standard Debian, as well as other distributions. `,description:"",tags:null,title:"Distributions",uri:"/linux/distributions/index.html"},{content:`Linux is a powerful and flexible operating system that is widely used in a variety of settings, from personal computers to servers and supercomputers. One of the strengths of Linux is the wealth of documentation and help available to users. Below are several options to get documentation or help about commands and the system in general:
man pages Short for manual pages, the man program is in charge of searching and showing documentation.
A given topic may have multiple pages associated with it and there is a default order determining which one is displayed when no options or section number is specified (in /etc/man_db.conf) The man pages are divided into chapters numbered 1 through 9 man command #Shows the manual entry for the command man -f command #Lists all entries (can be more than one) for the command whatis command #Same as above man -k command #List all entries where the command is mentioned (can be from other commands) apropos command #Same as above man -a command #display all "command" pages in all chapters, one after the other TLDR As an alternative for the man pages, the the tldr-pages project provides summarized documentation for commands, with a focus on practical examples. It does not come installed by default, but after installing it, here is an example when running tldr tldr :
foo@bar:~$ tldr tldr tldr Display simple help pages for command-line tools from the tldr-pages project.More information: https://tldr.sh. - Print the tldr page for a specific command (hint: this is how you got here!): tldr {{command}} - Print the tldr page for a specific subcommand: tldr {{command}}-{{subcommand}} - Print the tldr page for a command for a specific [p]latform: tldr -p {{android|linux|osx|sunos|windows}} {{command}} - [u]pdate the local cache of tldr pages: tldr -u GNU Info Similar to man but works with subsections and links Accessible through info tool. To navigate:
Action Key Move Arrows Next Page Page Up Previous Page Page Down Select menu item Enter Quit q Help h Go to next n Go to previous p Move one node up in the index u --help and help --help :Most commands provide a short way to get some reference passing the --help flag. help Is a program that can be used inside bash shells to get help about commands that run especially built-in bash versions. A list of these commands is shown using help Other sources Include:
Desktop help system: All Linux desktop systems have a graphical help application. This contains desktop specific help as well as some rendered man and info pages. Can be ran from GUI or CLI (For example, for GNOME gnome-help or yelp) Package documentation: Linux documentation is also available as part of the package management system. Usually, this documentation is directly pulled from the upstream source code, but it can also contain information about how the distribution packaged and set up the software. Normally available in /usr/share/doc Online resources: Include forums, and doc pages. Also ebooks, like this one `,description:"",tags:null,title:"Documentation and Help",uri:"/linux/documentation-and-help/index.html"},{content:`The Linux file system structure is organized into a tree-like hierarchy, starting from the root directory /. The root directory contains several standard subdirectories, each serving a specific purpose.
Good to know Similar information can be found using man hier
Here is a list of the standard folders in the Linux filesystem hierarchy:
/bin - Binary executables for system \u0026 users. This directory contains essential command line utilities, such as ls, cat, and cp, that are required for basic system operation and are accessible by both the system and users.
/sbin - Binary executables for system administrator only. This directory contains utilities that are necessary for system administration, such as init, fdisk, and ip. These utilities can only be executed by the root user or other users with administrative privileges.
/etc - Configuration files for system \u0026 applications. This directory contains configuration files for the system, as well as for applications and services installed on the system. These files are often human-readable and can be edited to modify the behavior of the system and its applications.
/dev - Device files for attached devices. This directory contains special files, also known as device files, that represent and provide access to the various devices attached to the system, such as hard drives, keyboards, and printers. The directory is initially empty, when not mounted. udev which manages devices in linux, then creates entries dynamically when devices are found
/lib - Libraries for executables in /bin \u0026 /sbin. This directory contains libraries and shared objects required by the executables in the /bin and /sbin directories. Libraries are collections of code that can be reused by multiple programs, improving system efficiency.
/boot - Files for system booting. This directory contains files necessary for booting the system, such as the Linux kernel, initial RAM disk, and boot loader configuration files.
/var - Files that change frequently (logs, spool, temp). This directory contains files and directories that change frequently, such as logs, spool directories, and temporary files. These files are usually deleted or recreated every time the system is restarted.
/tmp - Temporary files deleted on restart. This directory contains temporary files that are deleted when the system is restarted. These files are used by applications and services to store data temporarily.
/usr - User-related data (apps, libs, docs, user homes). This directory contains files and directories related to users, such as user-installed applications, libraries, documentation. This directory contains non essential binaries, and has its own tree, this means, it has /usr/bin, usr/sbin, etc.
/home - Home directories of users. This directory contains a subdirectory for each user on the system, which serves as that user’s home directory. The home directory typically contains personal configuration files, documents, and other files specific to each user. The only exception is the root user, whose home is /root
/media - Mount points for removable media. This directory contains subdirectories for mounting removable storage devices, such as USB drives and CD-ROMs. Each mounted device is represented by a subdirectory in /media, allowing for easy access to the files and directories on the device. In modern distributions,can be named /run
/mnt - Mount points for file systems temporarily mounted. This directory is similar to /media, but it is used for temporarily mounting file systems, such as network file systems, that are not meant to persist across reboots.
/opt - Optional software installation. This directory is intended for the installation of optional software packages that are not part of the standard Linux distribution. Each software package is installed in its own subdirectory within /opt, making it easy to manage and remove the software if necessary.
/proc - Process information file system. This directory is a virtual file system that provides information about the system and running processes. The files in this file system are not stored on disk like traditional files, but are generated on-the-fly by the kernel. The /proc file system is used to provide information about system resources, such as memory usage, system uptime, and CPU utilization, as well as information about running processes, such as their process ID, memory usage, and status.
`,description:"",tags:null,title:"Filesystem Architecture",uri:"/linux/system/filesystem-architecture/index.html"},{content:`Linux is an open source operating system (OS). An operating system is the software that directly manages a system’s hardware and resources, like CPU, memory, and storage. The OS sits between applications and hardware and makes the connections between all of your software and the physical resources that do the work.
In particular Linux provides the kernel, on top of which all different OS (Distributions) are built
`,description:"",tags:null,title:"Linux",uri:"/linux/index.html"},{content:"",description:"",tags:null,title:"System",uri:"/linux/system/index.html"},{content:"",description:"",tags:null,title:"Using a Linux System",uri:"/linux/using-a-linux-system/index.html"},{content:`What is? Git is a version control system. In other words it registers changes on a set of files.
Good to know Git uses SHA-1 to reference a version of a file or files.
Basic Workflow The basic workflow of Git is based on 3 states that files can be at:
The file (or files) are in the working directory, where they are modified Changes (modified files) are added to the staging area Staged changes are then committed to the git repository. This creates a version of the file (with an assigned SHA-1 id) called a commit. `,description:"",tags:null,title:"Git",uri:"/git/index.html"},{content:`Git offers different commands that allow to “travel back in time” or undo changes
git checkout Detached HEAD Using git checkout \u003cCOMMIT\u003e leads to Detached HEAD state.
This state, refers to when HEAD, instead of pointing to a branch reference (like usually) points to a specific commit.
This state is useful for:
Looking around the state of a repo Make experimental changes They can be committed and discarded just by switching to a branch They can be kept if creating a new branch from the detached HEAD The last option, allows to branch out on a particular commit in the repo history by reattaching the HEAD
Tip Commits can also be referenced from HEAD instead of the commit hash. So git checkout HEAD~1 takes HEAD back one commit, and so on.
Discard changes git checkout HEAD \u003cfiles\u003e will revert all files to the HEAD (To the last commit made). Another way to do the same thing is git checkout -- \u003cfiles\u003e
git restore This new command was introduce to limit the wide functionality of git checkout. It can do two things:
Discard changes Same functionality as git checkout HEAD \u003cfiles\u003e is achieved with
git restore \u003cfiles\u003e Good to know Restore also allows to set up a “source” different than HEAD to restore files like git restore --source HEAD~1 \u003cfiles\u003e
Unstage files To remove a file from the staging area and take it back to the working directory:
git restore --staged \u003cfile\u003e git reset This commands resets the state of the current branch to an specific commit. It comes in two flavors:
git reset \u003cCOMMIT\u003e: Will delete the commits but keep the changes in the working directory. This is specially useful when commits were added to the wrong branch git reset --hard \u003cCOMMIT\u003e. Will delete the commits and remove the changes git revert Has a very similar effect to git reset, but this command creates a new commit that reverts the changes of another commit :
Important When dealing with collaboration workflows, it is recommended to use revert instead of reset to undo changes. This way, the history that other people have does not have to be rewritten which can lead to issues
`,description:"",tags:null,title:"Undo Changes",uri:"/git/undo-changes/index.html"},{content:`What is stashing? git stash temporarily shelves (or stashes) changes made in a branch, that are not yet commited. This ways, you can store the changes without making a commit and switch context (or branch) to work on something else.
It avoids conflicts and taking changes with you when you switch branches
How to work with stash? The git stash works like a traditional stack. This means is a LIFO data structure in which data can be pushed or popped. In this case, data being the changes made.
git stash save Save uncommitted changes (staged and unstaged) into the stash Also works with git stash git stash pop Get the top of the stack (most recent stashed changes) and apply them to the working directory Removes the changes from the stash git stash apply Similar to pop but does not remove it from stash Useful to apply changes in multiple places git stash list When calling git stash multiple times, all changes go the the stack git stash list shows all stashes and the last commit when they were saved If the changes were saved with git stash save "message",it will also show the message. One can also apply or pop a particular stash with git stash apply stash@{2} A particular stash can also be dropped with git stash drop stash@{2} git stash clear drops all stashes `,description:"",tags:null,title:"Stashing",uri:"/git/stashing/index.html"},{content:`What is a diff? A diff is the output of using the git diff command. Is a text that allows to view differences or changes between commits, branches, files, working directory and many other things.
Example:
diff --git a/rainbow.txt b/rainbow.txt index 0b75516..26ec8e7 100644 --- a/rainbow.txt +++ b/rainbow.txt @@ -3,4 +3,5 @@ orange yellow green blue -purple +indigo +violet How to read a diff Here are the more meaningful lines in the example below:
The first line shows which two files are being compared. Is normally the same file but can be set up to be different. Original is going to be A and new is B diff --git a/rainbow.txt b/rainbow.txt - will be used for representing changes in file a, and + for changes in file b --- a/rainbow.txt +++ b/rainbow.txt Next the chunks will start. A diff will only show portions or chunks of files that were modified together with some context (lines before and after). The first thing is the header. In this case it means: From file a, 4 lines are extracted starting from line 3 (in the chunk) and from file b, 5 lines are extracted starting from line 3 (in the chunk) @@ -3,4 +3,5 @@ orange Finally, the changes are shown with the symbols relating to the files as explained above yellow green blue -purple +indigo +violet In this case, in file A, the last line was purple. Meanwhile in file B, purple was removed and indigo and violet were added
How to create a diff There a different ways to run the git diff command according to what you want to compare:
git diff will show changes in the working directory that are not in staging yet. In other words, compares the working directory with the staging area
git diff HEAD will compare HEAD and the working directory. In other words, it shows changes in the working directory since the last commit. Different to above it will show staged and unstaged changes.
git diff --staged or git diff --cached will compare HEAD and the staging area. It will show the changes that will be committed.
It is also possible to combine this options with different targets:
git diff \u003cOPS\u003e file shows changes for a specific file
git diff \u003cOPS\u003e branch1..branch2 or git diff \u003cOPS\u003e branch1 branch2 will compare two branches. The order in which they are passed determines which is considered A and B (First is always the “base”). In addition, adding a file name at the end, will limit the comparison to a specific file
git diff commit1..commit2 will compare changes between two commits, passing the hash of the commits. Same as above, the order influences which is A and B.
`,description:"",tags:null,title:"Diffs",uri:"/git/diffs/index.html"},{content:`What are branches? In GIT each commit, identified by a unique hash, has a reference to its parent commit
Branches can be tought of as alernate timelines in a project. They exist at the same time but are completely different contexts, so changes in a branch dont affect other branches.
In detail, branching happens when a commit has more that one child commit. In a techinical manner, branches are a reference to a commit (that has a series of parent commits) like shown below:
HEAD pointer Points to the current location in the repository ( a branch reference ) The branch reference is just the reference to the last commit Commands for branching git branch Shows all local branches of a repository. git branch -r will show remote branches and git branch -a will show all of them. If used with a name (git branch name) it will create (but not switch) a new branch based on the current HEAD. With the -d flag, it can be used to delete branches. (-D to force delete) The git branch -m new_name will change the name of the current branch (current HEAD) git switch Allows to switch between existing branches git switch -c name can be used to create a new branch and switch to it git checkout Allows to switch between existing branches Older command with lots of extra functionalities git checkout -b name can be used to create a new branch and switch to it Attention Uncommited changes will be lost if switching branches (can be stashed). Only if the changes do not conflict, for example new files that dont exist, will these come to the new branch
Merging branches When working with branches, most of the use cases involves bringing the work done in a branch into the original (or other) branch.
Incorporating changes from one branch to the other, is done with the git merge command.
git merge always merges to the current HEAD branch.
In summary the process is the following:
Switch to target branch (e.g git switch master) Merge branch (e.g git merge mybranch) According to the type of differences accross the branches, there could be:
Different types of merges Merge conflicts Merge Types Fast forward:
Simplest type of merge Target branch is just behind merging branch In other words, the merging branch just have some extra commits. Always automatically merged Merge Commit:
More common There is commits in the target branch that are not in the merging one. Can be automatically merged or not, depending on conflicts. Makes a commit. Normally asks for a commit message Merge Conflicts If a merge operation involves a file that is present but different in both branches, a merge conflict occur. In that case, git cannot decide which “version” should stay, so automatic merging is deactivated and one has to resolve the conflicts manually:
Files with conflict get “decorated” with \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD and \u003e\u003e\u003e\u003e\u003e\u003e\u003e branch to indicate which changes belong to which branch One decides which to keep (or combines both) One removes the decorators The files must be saved and committed to apply the merge Tools like VSCode offer a GUI for resolving conflicts `,description:"",tags:null,title:"Branches",uri:"/git/branches/index.html"},{content:"",description:"",tags:null,title:"Azure",uri:"/azure/index.html"},{content:`Definition Delivery of computing services over the internet (common IT infrastructure such as virtual machines, storage, databases, and networking). Cloud services also expand the traditional IT offerings to include things like Internet of Things (IoT), machine learning (ML), and artificial intelligence (AI). It allows to move capital expenditure (servers, datacenters, etc) into operational expenditure (cloud costs). Benefits High availability: Always available (SLA) Scalability: Vertical: Ease to add more power to machines Horizontal: Ease to add more machines Reliability: Decentralized, globally distributed Predictability: Constant performance and costs Security: Different levels of access, built in protection Governance: Ease to implement compliance Manageability: Ease to add/delete resources and interact with infrastructure Models 3 different models:
Public Cloud: Build controlled and maintained by a third party Available to the public Hybrid Cloud: Use private and public clouds interconnected Private Cloud: Cloud used by a single entity On premises Offers total control More cost and complexity Service Types: Cloud providers distinguish 3 types of service. Each service place responsibility to the provider or the customer side (Shared responsibility model). These are:
IaaS: Infrastructure as a service Most responsibility to the customer Provider maintains and manages physical infrastructure Examples include VM services, virtual networks, etc. PaaS Platform as a service Middleground Provider additionally maintains OS, dev tools, etc. Examples like Azure app services, AKS SaaS Software as a service Complete managed solution Examples include Managed dbs The different responsibilities for each service type are shown below
`,description:"",tags:null,title:"Cloud Concepts",uri:"/azure/cloudconcepts/index.html"},{content:`The key component of git is the commits. A commit is single point in the Git history; the entire history of a project is represented as a set of interrelated commits.
Good practice By good practice, commits should be atomic. This means each commit should relate to only one feature. This makes it easier to control, and roll back.
Commit Message A commit contains the current contents of the index and the given log message describing the changes.
The commit message should follow:
Is recommended by Git that the message is written in present tense + imperative Similar to giving orders to the machine Some examples: Fix bug in template code Make script compatible with centos Ammending Ammending a commit replaces the tip of the current branch by creating a new commit that starts from the last one.
In practice it can be used to “fix” the last commit.
Remember The changes to ammend need to be staged
Ignoring files and directories Files that should not bre tracked by git can be specified in a .gitignore file.
The file supports files, directories and also glob expressions to match several files at the same time.
More information can be seen in the https://git-scm.com/docs/gitignore
`,description:"",tags:null,title:"Commiting",uri:"/git/commiting/index.html"},{content:`Below are some of the most used commands when using git from the command line:
git init Initializes a git repository in the current directory. This is done by creating a hidden .git directory. Git docs If used with a name as an argument like git init example It will first create a folder called example and inside this folder initialize the repo.
Tip To make a directory not a git repository anymore, just delete the hidden .git folder.
git status Shows the current state of the files according to the basic workflow (un-tracked, staged). Git docs git add Normally used like git add file it adds a file to staging. This is done before committing because only staged files (or changes) are added to the commit.
Git docs
If used like
git add -A or
git add . Adds all the files that have been modified
git commit Allows to create a commit for the staged changes. Git docs To commit with a message directly:
git commit -m "message" Default editor If called without arguments, the command will prompt for a commit message using the default editor. This can be changed with git config --global core.editor More info here git log Retrieves a complete list of commit history for the repo
Its output can be compacted with the --oneline flag Git docs `,description:"",tags:null,title:"Basic Commands",uri:"/git/basic-commands/index.html"},{content:"",description:"",tags:null,title:"Categories",uri:"/categories/index.html"},{content:"",description:"",tags:null,title:"Tags",uri:"/tags/index.html"}]