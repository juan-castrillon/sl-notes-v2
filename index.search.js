var relearn_search_index=[{content:`Welcome! Welcome to my personal collection of notes and summaries on tech related topics! this is just a big cheat sheet where I store all the things that I learn in courses, certifications, on classes and on jobs in order for me to have easy access from anywhere.
Here you will find a wealth of information on various tech subjects, including programming languages, DevOps Tools, cloud, software engineering, and more. I have organized my notes by topic and subject, making it easy for you (but most probably me) to find the information needed.
If you are someone that is not me, I hope you find my notes to be helpful and informative.
Thank you for visiting my site, and happy learning!
`,description:"",tags:null,title:"Notes",uri:"/index.html"},{content:`Package managers The process of installing software on Linux can vary depending on the distribution you are using. Here is a general overview of the common methods used to install software on different Linux distributions:
Debian and Ubuntu: Software is typically installed using the apt package manager. Low level manager is normally dpkg Red Hat and Fedora: Software is typically installed using the yum package manager. Low level manager is normally rpm SUSE Family: Software is typically installed using the zypper package manager. Low level manager is normally rpm Other distributions: Some other Linux distributions, such as Slackware, use their own package management systems. You can refer to the distribution’s documentation for information on how to install software. Each package contains the files and other instructions needed to make one software component work well and cooperate with the other components that comprise the entire system.
All linux distributions have a low level and a high level package manager:
The low level, is in charge of installing single packages correctly. The high level usually calls the low level one and additionally, is in charge of resolving dependencies. Other ways of installing It’s also worth noting that there are other ways to install software on Linux, such as downloading binaries, compiling from source code, using flatpak, or using snap which is increasingly popular, but package managers are the most common and recommended method.
Common operations Operation RH Family Debian Family Install package rpm -i foo.rpm dpkg --install foo.deb Install package, dependencies yum install foo apt-get install foo or apt install foo Remove package rpm -e foo.rpm dpkg --remove foo.deb Remove package, dependencies yum remove foo apt-get remove foo or apt remove foo Remove package, deps, and config apt-get remove --purge foo or apt purge foo Remove “left-behind” packages yum autoremove apt-get autoremove or apt autoremove Update package rpm -U foo.rpm dpkg --install foo.deb Update package, dependencies yum update foo apt-get install foo Update entire system yum update apt-get dist-upgrade Show all installed packages rpm -qa or yum list installed dpkg --list or apt list --installed Get information on package rpm -qil foo dpkg --listfiles foo Show packages named foo yum list "foo" apt-cache search foo or apt search foo Show all available packages yum list apt-cache dumpavail foo What package is file part of? rpm -qf file dpkg --search file Debian-based distributions APT and APT-GET apt and apt-get are both package management tools for Debian and Ubuntu-based Linux distributions but apt is a more user-friendly tool, abstracting some of the functionality from other commands. apt-get is considered to be more powerful and flexible, and mostly used in automation for the -y option for example.
Repositories apt (or apt-get) stores a list of repositories or software channels in the file /etc/apt/sources.list and in any file with the suffix .list under the directory /etc/apt/sources.list.d/
A software repository is a collection of software packages that can be installed on the system. These packages are organized and managed by Ubuntu developers and are easily accessible to users via the apt package manager.
By editing these files from the command line, we can add, remove, or temporarily disable software repositories.
Format A typical line on the file looks like this:
deb http://ch.archive.ubuntu.com/ubuntu/ saucy main restricted deb: These repositories contain binaries or precompiled packages. These repositories are required for most users. deb-src: These repositories contain the source code of the packages. Useful for developers. http://archive.ubuntu.com/ubuntu: The URI (Uniform Resource Identifier), in this case a location on the internet. saucy is the release name or version of the distribution (found with lsb_release -sc). main \u0026 restricted are the section names or components. There can be several section names, separated by spaces. Adding new repositories Adding a new line with the above format will add a new repository. To “load” them is important to retrieve the updated package list with
sudo apt-get update PPA Repositories Adding Launchpad PPA (Personal Package Archive) is possible conveniently via the command add-apt-repository in Ubuntu or addrepo on Debian. It looks like: sudo add-apt-repository ppa:\u003crepository-name\u003e
`,description:"",tags:null,title:"Installing Software",uri:"/linux/using-a-linux-system/installing-software/index.html"},{content:`The boot process In linux, the boot process occurs when initiating the system. It goes from the moment the computer is powered on until the UI is fully operational and ready.
This is a sequential Process
1. BIOS Basic Input Output System Initializes the hardware (including monitor and keyboard) Tests the main memory Normally installed in a ROM in the motherboard 2. Boot Loader \u0026 Kernel First Stage: Master Boot Record (MBR) examines the partition table and finds a bootable partition. Also finds a second-stage bootloader (e.g. GRUB) and loads in into RAM Second Stage: Programs like GRUB allow to choose the OS. Once decided, it loads the kernel and the initial RAM disks (in RAM) and passes control to the kernel. (Kernel first job is to decompress itself) When the kernel is loaded in RAM, it initializes and configures the computer’s memory and also configures all the hardware attached to the system. Second stage bootloaders are located in /boot Some second-stage bootloaders are GRUB (for GRand Unified Boot loader), ISOLINUX (for booting from removable media), and DAS U-Boot (for booting on embedded devices/appliances) 3. Initial RAM Disk initramfs Contains programs and binary files that perform all actions needed to mount the proper root filesystem After the root filesystem has been found, it is checked for errors and mounted. At boot time, the boot loader loads the kernel and the initramfs image into memory and starts the kernel. The kernel checks for the presence of the initramfs and, if found, mounts it as / and runs /sbin/init. 4. /sbin/init init handles the mounting and pivoting over to the final real root filesystem. Normally a shell script. Is the parent process of nearly all processes Near the end of the boot process, init starts a number of text-mode login prompts. In case of an OS with a GUI, then this is loaded and displayed instead /sbin/init and Services Apart from being the initial process, the init script is also responsible for:
Keeping the system running (Managing other processes, cleaning up after them, etc) Shut down cleanly Methods for this startup are systemd and Upstart
systemd Current systems use systemd instead of init because it simplifies the init process and makes it faster (parallel service execution instead of sequential) Complicated startup shell scripts are replaced with simpler configuration files /sbin/init now just points to /lib/systemd/systemd; Some commands are:
Starting, stopping, restarting a service (using nfs as an example) on a currently running system:
sudo systemctl start|stop|restart nfs.service Enabling or disabling a system service from starting up at system boot:
sudo systemctl enable|disable nfs.service `,description:"",tags:null,title:"System Startup",uri:"/linux/system/system-startup/index.html"},{content:`The Linux kernel is the core of the operating system. A full Linux distribution consists of the kernel plus a number of other software tools for file-related operations, user management, and software package management
Distribution Families There are more than 200 distributions. The most commonly used can be categorized in three families:
Red Hat Family Systems (including CentOS and Fedora) SUSE Family Systems (including openSUSE) Debian Family Systems (including Ubuntu and Linux Mint). Red Hat Some of the key facts about the Red Hat distribution family are:
Fedora serves as an upstream testing platform for RHEL. CentOS is a close clone of RHEL, while Oracle Linux is mostly a copy with some changes (in fact, CentOS has been part of Red Hat since 2014). CentOS 8 has reached end of life while CentOS 7 will do it in 2024 A heavily patched version 3.10 kernel is used in RHEL/CentOS 7, while version 4.18 is used in RHEL/CentOS 8. It supports hardware platforms such as Intel x86, Arm, Itanium, PowerPC, and IBM System z. It uses the yum and dnf RPM-based yum package managers to install, update, and remove packages in the system. RHEL is widely used by enterprises which host their own systems. SUSE Some of the key facts about the SUSE family are listed below:
SUSE Linux Enterprise Server (SLES) is upstream for openSUSE. Kernel version 4.12 is used in openSUSE Leap 15. It uses the RPM-based zypper package manager to install, update, and remove packages in the system. It includes the YaST (Yet Another Setup Tool) application for system administration purposes. SLES is widely used in retail and many other sectors. Debian Some key facts about the Debian family are listed below:
The Debian family is upstream for Ubuntu, and Ubuntu is upstream for Linux Mint and others. Kernel version 4.15 is used in Ubuntu 18.04 LTS. It uses the DPKG-based APT package manager (using apt, apt-get, apt-cache, etc.) to install, update, and remove packages in the system. Ubuntu has been widely used for cloud deployments. While Ubuntu is built on top of Debian and is GNOME-based under the hood, it differs visually from the interface on standard Debian, as well as other distributions. `,description:"",tags:null,title:"Distributions",uri:"/linux/distributions/index.html"},{content:`Linux is a powerful and flexible operating system that is widely used in a variety of settings, from personal computers to servers and supercomputers. One of the strengths of Linux is the wealth of documentation and help available to users. Below are several options to get documentation or help about commands and the system in general:
man pages Short for manual pages, the man program is in charge of searching and showing documentation.
A given topic may have multiple pages associated with it and there is a default order determining which one is displayed when no options or section number is specified (in /etc/man_db.conf) The man pages are divided into chapters numbered 1 through 9 man command #Shows the manual entry for the command man -f command #Lists all entries (can be more than one) for the command whatis command #Same as above man -k command #List all entries where the command is mentioned (can be from other commands) apropos command #Same as above man -a command #display all "command" pages in all chapters, one after the other TLDR As an alternative for the man pages, the the tldr-pages project provides summarized documentation for commands, with a focus on practical examples. It does not come installed by default, but after installing it, here is an example when running tldr tldr :
foo@bar:~$ tldr tldr tldr Display simple help pages for command-line tools from the tldr-pages project.More information: https://tldr.sh. - Print the tldr page for a specific command (hint: this is how you got here!): tldr {{command}} - Print the tldr page for a specific subcommand: tldr {{command}}-{{subcommand}} - Print the tldr page for a command for a specific [p]latform: tldr -p {{android|linux|osx|sunos|windows}} {{command}} - [u]pdate the local cache of tldr pages: tldr -u GNU Info Similar to man but works with subsections and links Accessible through info tool. To navigate:
Action Key Move Arrows Next Page Page Up Previous Page Page Down Select menu item Enter Quit q Help h Go to next n Go to previous p Move one node up in the index u --help and help --help :Most commands provide a short way to get some reference passing the --help flag. help Is a program that can be used inside bash shells to get help about commands that run especially built-in bash versions. A list of these commands is shown using help Other sources Include:
Desktop help system: All Linux desktop systems have a graphical help application. This contains desktop specific help as well as some rendered man and info pages. Can be ran from GUI or CLI (For example, for GNOME gnome-help or yelp) Package documentation: Linux documentation is also available as part of the package management system. Usually, this documentation is directly pulled from the upstream source code, but it can also contain information about how the distribution packaged and set up the software. Normally available in /usr/share/doc Online resources: Include forums, and doc pages. Also ebooks, like this one `,description:"",tags:null,title:"Documentation and Help",uri:"/linux/documentation-and-help/index.html"},{content:"",description:"",tags:null,title:"Go",uri:"/go/index.html"},{content:"",description:"",tags:null,title:"Language Basics",uri:"/go/language-basics/index.html"},{content:`Types Go is a statically typed language. This means that variables are assigned a type when created and can only hold values of that type. This helps with avoiding runtime errors by catching them at compile-time
Go supports several types. The most common being
Type Description Zero Value int Integer value, can be 64 or 32 bits depending on the system it runs on 0 bool Boolean value false string String of UTF-8 characters "" slice Growable list of a type nil map Key-value data structure nil struct A collection of named attributes (Similar to objects in other languages) Empty struct interface A type that holds a value with defined methods nil pointers A type that stores an address in memory of a variable not the variable nil channels A pipe (buffered or not) for sending data asynchronously nil Other types include more control over the size of the variables, as well as some particular use cases like complex numbers:
Type Description Zero value uint Unsigned 32 or 64 bit integer 0 uint8 Unsigned 8 bit integer (0-255) 0 uint16 Unsigned 16 bit integer (0-65535) 0 uint32 Unsigned 32 bit integer (0-4294967295) 0 uint64 Unsigned 64 bit integer (0-18446744073709551615) 0 int8 Signed 8 bit integer (-128-127) 0 int16 Signed 16 bit integer (-32768-32767) 0 int32 Signed 32 bit integer (-2147483648 - 2147483647) 0 int64 Signed 64 bit integer (-9223372036854775808 - 9223372036854775807) 0 float32 32 bit floating point (decimal) values 0 float64 64 bit floating point (decimal) values 0 complex64 Complex numbers with real and imaginary part float32 (0+0i) complex128 Complex numbers with real and imaginary part float64 (0+0i) byte Alias for uint8 0 rune Alias for int32 0 uintptr Unsigned integer large enough to hold any pointer address (32 or 64 bit). 0 array Fix list of items [] function A function can be stored in a variable (functional programming) nil Declaring variables Go supports two types of variable declaration:
Creation and assignment: This type can be used to declare variables at the package and function levels. If using just the creation statement (var i int) the variable will have the corresponding zero value var i int // Create for a given type i = 3 // Assign the value var j = 3 // Infers the type Single statement: This can only be used in function levels i := 3 // Creates and infers the type, then assigns the value Redeclare variables Once declared a value cannot be redeclared in the same scope, only a new value can be assigned, so the following is not valid
func main() { i := 3 i := 5 } Scope of variables Depending on where they are declared variables can be “visible” to different scopes:
Package scoped: When declared at the package level, it can be seen by the entire package package oe var word = "hello" func afunction(){} Function scoped: Only visible inside a particular function func afunction(){ var i = 3 } func another() { // i is not accessible } Statement scoped: Only visible for an statement (loop, if) inside a function func af() { for i := 0; i \u003c 10; i++ { // i is accessible } // i is not visible } Shadowing Redeclaring variables in different scopes can affect the values that can be read. This is a very common bug know as variable shadowing. Below an example
package main var word = "hello" func main(){ var word = "world" // In this scope word is world } func other(){ // In here word is hello } `,description:"",tags:null,title:"Variables",uri:"/go/language-basics/variables/index.html"},{content:`Similar to libraries or modules in other languages, go uses the concept of packages to refer to reusable blocks of code that can be imported and used in other code.
Working with packages is straight forward. One can:
Declare packages: When structuring an application, to split the functionality logically Import packages: While coding to use functions from the standard library, third party packages or even other packages in the app Declaring packages At the beginning of each .go file, the package of the file needs to be declared. It must be the first code to appear and can only be preceded by comments (most of the times documenting the package). Here is an example:
// Package example contains a lot of invisible functions and variables package example Files in a package All files in a directory must be in the same package. Most commonly the package is named after the directory where the files are.
Importing packages Packages need to be imported to be used, this is done always in an import block at the beginning of the file:
// This package will import some other package example import ( "fmt" "github.com/someguy/apackage" other "github.com/otherguy/apackage" ) In the example above:
fmt is a package from the stdlib github.com/someguy/apackage is an example of a third party package github.com/otherguy/apackage is another third party package imported with the alias other to avoid naming conflicts when calling apackage.afunction Used packages Go has compile rules that enforce that every imported package must be used. This helps optimize binary sizes. An option to avoid this, is to use a side effects import, which just loads a package. This should always be done in the package main like
import ( "fmt" _ "sync" // Just for some effect ) `,description:"",tags:null,title:"Packages",uri:"/go/language-basics/packages/index.html"},{content:`The Go teams offers the go playground. This is a web code editor and compiler that allows to write and run go code.
The Go Playground has several features that make it a useful tool:
Easy to use: The Playground has a simple interface that makes it easy to write and test out code.
Interactive: The Playground allows you to write code and see the results in real-time, making it a great tool for learning and experimenting with Go.
Shareable: You can share your code snippets with others by sharing the URL of the Playground page. This makes it easy to collaborate with others and get feedback on your code.
Code formatting: The Playground automatically formats your code as you type, making it easier to read and understand.
Import support: You can import packages and libraries from the Go standard library or from third-party sources, allowing you to explore and experiment with a wide range of Go code.
`,description:"",tags:null,title:"Playground",uri:"/go/playground/index.html"},{content:"",description:"",tags:null,title:"Collaboration",uri:"/git/collaboration/index.html"},{content:`What is? Git is a version control system. In other words it registers changes on a set of files.
Good to know Git uses SHA-1 to reference a version of a file or files.
Basic Workflow The basic workflow of Git is based on 3 states that files can be at:
The file (or files) are in the working directory, where they are modified Changes (modified files) are added to the staging area Staged changes are then committed to the git repository. This creates a version of the file (with an assigned SHA-1 id) called a commit. `,description:"",tags:null,title:"Git",uri:"/git/index.html"},{content:`There are several repository management tools that allow to take the git workflow and ease collaboration based on the cloud. These are hosting platform for git repositories and their use is supported by native git commands. The most popular are:
Github Gitlab Bitbucket Basic Worflow When working with remotes there is 3 general operations performed:
Setup Get data Post data When creating a new project or linking a local repo to the cloud for the first time, an empty remote should be created, after there is two options:
If a local repo with data exist:
Add the remote Push the data If its a new project
Clone the empty remote Do changes Push the data Setup Any git repository can be configured with a remote. In order to get a list of the remotes of a repository,the following command is used
git remote -v One (or more) can be added to the repository, renamed or deleted
Adding a remote To add a remote the command is:
git remote add \u003cname\u003e \u003curl\u003e Where:
\u003cname\u003e is the name to give the remote. In most cases, when adding the first remote this is called origin but is just a convention \u003curl\u003e is the HTTPS or SSH url of the repository in Github, gitlab, etc. SSH Setup In order to set up SSH Authentication, an SSH Key needs to be created and set up in the platform (github,gitlab, etc). This allows “password-less” flow which is way nicer than having to input the password every time a commit is pushed.
Main vs master Gihub and gitlab among others are pushing for using the term main instead of master for the main branch of projects. In that sense, any new repo created will have the main branch if created with a file (for exaple a README). To adapt this, git branch -M main can be run to change the local master branch’s name before pushing
Renaming a remote The name of a remote can also be changed after creation with
git remote rename \u003cold\u003e \u003cnew\u003e Deleting a remote To delete a remote, the command is:
git remote remove \u003cname\u003e Getting Data Cloning a remote To “pull” a remote for the first time to a machine that does not have it, the clone command is used.
git clone \u003curl\u003e The command :
Copies the data from the remote Initializes a local git repo. Sets up remote tracking branch references pointing to the branches of the remote Remote tracking branches These are a pointer (just like any other branch) to the latest commit of a branch in the remote. For example origin/main points to the last known commit of the main branch in the remote origin. To see all remote tracking branch references in a repo, the command git branch -r helps. Its also worth noting that they can be checkout with git checkout origin/main which will show the state of the main branch in detached HEAD mode
Other branches When cloning, only the default branch (master or main) is accessible in the local repository. This is because the cloning process, although it creates RTB references for all remote branches, just “links” the one of the default branch to a local branch.
In order to access other remote branches locally is enough to use
git switch \u003cbranch_name\u003e where \u003cbranch_name\u003e is the same name as one of the remote branches. This will automatically:
Create a new local branch called \u003cbranch_name\u003e Link it with the RTB references for the remote branch Fetching git fetch allows to retrieve the latest changes from a remote repository without merging them into the local branch.
The command can be used as git fetch \u003cremote\u003e to fetch all available changes (all branches) or git fetch \u003cremote\u003e \u003cbranch\u003e to fetch a specific branch.
In more detail, it only updates the RTB references but not the local branches. So if running git fetch origin master, the origin/master reference will now point to the latest version, but the local master branch won’t be affected.
Seeing the changes Once fetched, the changes can be seen with git checkout in detached HEAD mode
Pulling git pull is similar to git fetch, but it also merges the changes from the remote repository into the local branch. This means that your local branch is automatically updated with the latest changes from the remote repository.
The command can be used like git pull \u003cremote\u003e \u003cbranch\u003e to pull changes from a specific branch. In addition, git pull will default the remote to origin and the branch to the RTB reference linked to the current branch.
In other words, it updates both the RTB reference (e.g. origin/master) and the current HEAD (e.g master)
Because of this, is critical to run the command in the correct place, as the current branch when the command is run will be the one updated.
fetch vs pull The main difference between git fetch and git pull is that git fetch only retrieves the changes from the remote repository, while git pull retrieves the changes and merges them into your local branch.
Pushing data In order to push or send local changes (commits) to the remote, the command push is used
git push \u003cremote\u003e \u003cbranch\u003e This command wil create a new branch on the remote (the first time) and push the changes on the local branch with the same name. For example git push origin master will push the changes from the local master branch to the remote master branch
To push to a branch with a different name, the whole syntax can be used:
git push \u003cremote\u003e \u003clocal_branch\u003e:\u003cremote_branch\u003e Upstream setup If the -u is added to the git push command, the remote branch is set and remembered as the “upstream” for the local branch. This means that git will link the two of them, so next time just git push will work.
`,description:"",tags:null,title:"Working with remotes",uri:"/git/collaboration/remotes/index.html"},{content:`What is it? A file system in Linux is the way in which files are stored, organized, and managed on a Linux operating system. It is responsible for managing the data on a storage device, such as a hard disk or solid-state drive, by dividing it into multiple sections or partitions. The file system determines the structure and organization of the files, as well as the methods used to access and modify them.
Info The most commonly used file systems in Linux are the ext4, btrfs, and xfs file systems. The file system chosen depends on the specific requirements of the system, such as performance, scalability, and reliability.
Partitions and multiple file systems In linux each filesystem occupies a disk partition. These are separated “logical drives” or sections inside a single (or more) real drives, but appear as different drives to the OS. Data is stored into different partitions for many reasons, including security or backup.
lsblk provides a tree-like view of the storage devices and their associated partitions, making it easy to see the hierarchical relationships between the different components of the system’s storage.For a graphical interface gparted can be used to check out the partitions in a system.
Mounting filesystems Different file systems are mounted on the filesystem tree. The mount points are just directories in which the new filesystem will live.
The utility mount is used for this task:
sudo mount /dev/sda5 /home #Mounts the filesystem in the sda5 device(partition) in /home sudo umount /home #Dismounts the filesystem This is a temporal way of mounting a filesystem and will get unmounted in reboot. In order to make it permanent, the etc/fstab file needs to be modified.
Add a new line to the file with the following format:
\u003cdevice\u003e \u003cmount point\u003e \u003cfile system type\u003e \u003coptions\u003e \u003cdump\u003e \u003cpass\u003e For example, to mount the file system located at /dev/sdb1 with the file system type ext4 to the mount point /mnt/data, the line would be:
/dev/sdb1 /mnt/data ext4 defaults 0 0 More information is available in man fstab
Good to know mounted alone, as well as df -Th will show all presently mounted filesystems
NFS A special kind of filesystem is a Network File System. The Network File System (NFS) is a protocol that allows a computer to share its files with other computers over a network. NFS enables seamless access to remote file systems as if they were local, allowing users to access and manage files on remote systems with the same ease as they do on their own computer.
It has a server and a client side
Server On the server, nfs runs a a daemon, and allows to share a directory in the server’s filesystem via NFS (with a network address)
sudo systemctl start nfs # Starts the NFS daemon On the /etc/exports file, the directories that are going to be shared are typed in. For example /projects *(rw) means that the /projects directory in the server will be shared (with read and write accesses).
Using exportfs -av notifies Linux of the changes. The NFS daemon can also be reset, and set to start on boot.
Client On the client, the filesystem is mounted like any other (Is also possible to modify fstab to boot with the filesystem mounted)
sudo mount servername:/projects /mnt/nfs/projects `,description:"",tags:null,title:"Filesystems",uri:"/linux/system/filesystems/index.html"},{content:`Linux is an open source operating system (OS). An operating system is the software that directly manages a system’s hardware and resources, like CPU, memory, and storage. The OS sits between applications and hardware and makes the connections between all of your software and the physical resources that do the work.
In particular Linux provides the kernel, on top of which all different OS (Distributions) are built
`,description:"",tags:null,title:"Linux",uri:"/linux/index.html"},{content:"",description:"",tags:null,title:"System",uri:"/linux/system/index.html"},{content:`The Linux file system structure is organized into a tree-like hierarchy, starting from the root directory /. The root directory contains several standard subdirectories, each serving a specific purpose.
Good to know Similar information can be found using man hier
Here is a list of the standard folders in the Linux filesystem hierarchy:
/bin - Binary executables for system \u0026 users. This directory contains essential command line utilities, such as ls, cat, and cp, that are required for basic system operation and are accessible by both the system and users.
/sbin - Binary executables for system administrator only. This directory contains utilities that are necessary for system administration, such as init, fdisk, and ip. These utilities can only be executed by the root user or other users with administrative privileges.
/etc - Configuration files for system \u0026 applications. This directory contains configuration files for the system, as well as for applications and services installed on the system. These files are often human-readable and can be edited to modify the behavior of the system and its applications.
/dev - Device files for attached devices. This directory contains special files, also known as device files, that represent and provide access to the various devices attached to the system, such as hard drives, keyboards, and printers. The directory is initially empty, when not mounted. udev which manages devices in linux, then creates entries dynamically when devices are found
/lib - Libraries for executables in /bin \u0026 /sbin. This directory contains libraries and shared objects required by the executables in the /bin and /sbin directories. Libraries are collections of code that can be reused by multiple programs, improving system efficiency.
/boot - Files for system booting. This directory contains files necessary for booting the system, such as the Linux kernel, initial RAM disk, and boot loader configuration files.
/var - Files that change frequently (logs, spool, temp). This directory contains files and directories that change frequently, such as logs, spool directories, and temporary files. These files are usually deleted or recreated every time the system is restarted.
/tmp - Temporary files deleted on restart. This directory contains temporary files that are deleted when the system is restarted. These files are used by applications and services to store data temporarily.
/usr - User-related data (apps, libs, docs, user homes). This directory contains files and directories related to users, such as user-installed applications, libraries, documentation. This directory contains non essential binaries, and has its own tree, this means, it has /usr/bin, usr/sbin, etc.
/home - Home directories of users. This directory contains a subdirectory for each user on the system, which serves as that user’s home directory. The home directory typically contains personal configuration files, documents, and other files specific to each user. The only exception is the root user, whose home is /root
/media - Mount points for removable media. This directory contains subdirectories for mounting removable storage devices, such as USB drives and CD-ROMs. Each mounted device is represented by a subdirectory in /media, allowing for easy access to the files and directories on the device. In modern distributions,can be named /run
/mnt - Mount points for file systems temporarily mounted. This directory is similar to /media, but it is used for temporarily mounting file systems, such as network file systems, that are not meant to persist across reboots.
/opt - Optional software installation. This directory is intended for the installation of optional software packages that are not part of the standard Linux distribution. Each software package is installed in its own subdirectory within /opt, making it easy to manage and remove the software if necessary.
/proc - Process information file system. This directory is a virtual file system that provides information about the system and running processes. The files in this file system are not stored on disk like traditional files, but are generated on-the-fly by the kernel. The /proc file system is used to provide information about system resources, such as memory usage, system uptime, and CPU utilization, as well as information about running processes, such as their process ID, memory usage, and status.
`,description:"",tags:null,title:"Filesystem Architecture",uri:"/linux/system/filesystem-architecture/index.html"},{content:"",description:"",tags:null,title:"Using a Linux System",uri:"/linux/using-a-linux-system/index.html"},{content:`Git offers different commands that allow to “travel back in time” or undo changes
git checkout Detached HEAD Using git checkout \u003cCOMMIT\u003e leads to Detached HEAD state.
This state, refers to when HEAD, instead of pointing to a branch reference (like usually) points to a specific commit.
This state is useful for:
Looking around the state of a repo Make experimental changes They can be committed and discarded just by switching to a branch They can be kept if creating a new branch from the detached HEAD The last option, allows to branch out on a particular commit in the repo history by reattaching the HEAD
Tip Commits can also be referenced from HEAD instead of the commit hash. So git checkout HEAD~1 takes HEAD back one commit, and so on.
Discard changes git checkout HEAD \u003cfiles\u003e will revert all files to the HEAD (To the last commit made). Another way to do the same thing is git checkout -- \u003cfiles\u003e
git restore This new command was introduce to limit the wide functionality of git checkout. It can do two things:
Discard changes Same functionality as git checkout HEAD \u003cfiles\u003e is achieved with
git restore \u003cfiles\u003e Good to know Restore also allows to set up a “source” different than HEAD to restore files like git restore --source HEAD~1 \u003cfiles\u003e
Unstage files To remove a file from the staging area and take it back to the working directory:
git restore --staged \u003cfile\u003e git reset This commands resets the state of the current branch to an specific commit. It comes in two flavors:
git reset \u003cCOMMIT\u003e: Will delete the commits but keep the changes in the working directory. This is specially useful when commits were added to the wrong branch git reset --hard \u003cCOMMIT\u003e. Will delete the commits and remove the changes git revert Has a very similar effect to git reset, but this command creates a new commit that reverts the changes of another commit :
Important When dealing with collaboration workflows, it is recommended to use revert instead of reset to undo changes. This way, the history that other people have does not have to be rewritten which can lead to issues
`,description:"",tags:null,title:"Undo Changes",uri:"/git/undo-changes/index.html"},{content:`What is stashing? git stash temporarily shelves (or stashes) changes made in a branch, that are not yet commited. This ways, you can store the changes without making a commit and switch context (or branch) to work on something else.
It avoids conflicts and taking changes with you when you switch branches
How to work with stash? The git stash works like a traditional stack. This means is a LIFO data structure in which data can be pushed or popped. In this case, data being the changes made.
git stash save Save uncommitted changes (staged and unstaged) into the stash Also works with git stash git stash pop Get the top of the stack (most recent stashed changes) and apply them to the working directory Removes the changes from the stash git stash apply Similar to pop but does not remove it from stash Useful to apply changes in multiple places git stash list When calling git stash multiple times, all changes go the the stack git stash list shows all stashes and the last commit when they were saved If the changes were saved with git stash save "message",it will also show the message. One can also apply or pop a particular stash with git stash apply stash@{2} A particular stash can also be dropped with git stash drop stash@{2} git stash clear drops all stashes `,description:"",tags:null,title:"Stashing",uri:"/git/stashing/index.html"},{content:`What is a diff? A diff is the output of using the git diff command. Is a text that allows to view differences or changes between commits, branches, files, working directory and many other things.
Example:
diff --git a/rainbow.txt b/rainbow.txt index 0b75516..26ec8e7 100644 --- a/rainbow.txt +++ b/rainbow.txt @@ -3,4 +3,5 @@ orange yellow green blue -purple +indigo +violet How to read a diff Here are the more meaningful lines in the example below:
The first line shows which two files are being compared. Is normally the same file but can be set up to be different. Original is going to be A and new is B diff --git a/rainbow.txt b/rainbow.txt - will be used for representing changes in file a, and + for changes in file b --- a/rainbow.txt +++ b/rainbow.txt Next the chunks will start. A diff will only show portions or chunks of files that were modified together with some context (lines before and after). The first thing is the header. In this case it means: From file a, 4 lines are extracted starting from line 3 (in the chunk) and from file b, 5 lines are extracted starting from line 3 (in the chunk) @@ -3,4 +3,5 @@ orange Finally, the changes are shown with the symbols relating to the files as explained above yellow green blue -purple +indigo +violet In this case, in file A, the last line was purple. Meanwhile in file B, purple was removed and indigo and violet were added
How to create a diff There a different ways to run the git diff command according to what you want to compare:
git diff will show changes in the working directory that are not in staging yet. In other words, compares the working directory with the staging area
git diff HEAD will compare HEAD and the working directory. In other words, it shows changes in the working directory since the last commit. Different to above it will show staged and unstaged changes.
git diff --staged or git diff --cached will compare HEAD and the staging area. It will show the changes that will be committed.
It is also possible to combine this options with different targets:
git diff \u003cOPS\u003e file shows changes for a specific file
git diff \u003cOPS\u003e branch1..branch2 or git diff \u003cOPS\u003e branch1 branch2 will compare two branches. The order in which they are passed determines which is considered A and B (First is always the “base”). In addition, adding a file name at the end, will limit the comparison to a specific file
git diff commit1..commit2 will compare changes between two commits, passing the hash of the commits. Same as above, the order influences which is A and B.
`,description:"",tags:null,title:"Diffs",uri:"/git/diffs/index.html"},{content:`What are branches? In GIT each commit, identified by a unique hash, has a reference to its parent commit
Branches can be tought of as alernate timelines in a project. They exist at the same time but are completely different contexts, so changes in a branch dont affect other branches.
In detail, branching happens when a commit has more that one child commit. In a techinical manner, branches are a reference to a commit (that has a series of parent commits) like shown below:
HEAD pointer Points to the current location in the repository ( a branch reference ) The branch reference is just the reference to the last commit Commands for branching git branch Shows all local branches of a repository. git branch -r will show remote branches and git branch -a will show all of them. If used with a name (git branch name) it will create (but not switch) a new branch based on the current HEAD. With the -d flag, it can be used to delete branches. (-D to force delete) The git branch -m new_name will change the name of the current branch (current HEAD) git switch Allows to switch between existing branches git switch -c name can be used to create a new branch and switch to it git checkout Allows to switch between existing branches Older command with lots of extra functionalities git checkout -b name can be used to create a new branch and switch to it Attention Uncommited changes will be lost if switching branches (can be stashed). Only if the changes do not conflict, for example new files that dont exist, will these come to the new branch
Merging branches When working with branches, most of the use cases involves bringing the work done in a branch into the original (or other) branch.
Incorporating changes from one branch to the other, is done with the git merge command.
git merge always merges to the current HEAD branch.
In summary the process is the following:
Switch to target branch (e.g git switch master) Merge branch (e.g git merge mybranch) According to the type of differences accross the branches, there could be:
Different types of merges Merge conflicts Merge Types Fast forward:
Simplest type of merge Target branch is just behind merging branch In other words, the merging branch just have some extra commits. Always automatically merged Merge Commit:
More common There is commits in the target branch that are not in the merging one. Can be automatically merged or not, depending on conflicts. Makes a commit. Normally asks for a commit message Merge Conflicts If a merge operation involves a file that is present but different in both branches, a merge conflict occur. In that case, git cannot decide which “version” should stay, so automatic merging is deactivated and one has to resolve the conflicts manually:
Files with conflict get “decorated” with \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD and \u003e\u003e\u003e\u003e\u003e\u003e\u003e branch to indicate which changes belong to which branch One decides which to keep (or combines both) One removes the decorators The files must be saved and committed to apply the merge Tools like VSCode offer a GUI for resolving conflicts `,description:"",tags:null,title:"Branches",uri:"/git/branches/index.html"},{content:"",description:"",tags:null,title:"Azure",uri:"/azure/index.html"},{content:`Definition Delivery of computing services over the internet (common IT infrastructure such as virtual machines, storage, databases, and networking). Cloud services also expand the traditional IT offerings to include things like Internet of Things (IoT), machine learning (ML), and artificial intelligence (AI). It allows to move capital expenditure (servers, datacenters, etc) into operational expenditure (cloud costs). Benefits High availability: Always available (SLA) Scalability: Vertical: Ease to add more power to machines Horizontal: Ease to add more machines Reliability: Decentralized, globally distributed Predictability: Constant performance and costs Security: Different levels of access, built in protection Governance: Ease to implement compliance Manageability: Ease to add/delete resources and interact with infrastructure Models 3 different models:
Public Cloud: Build controlled and maintained by a third party Available to the public Hybrid Cloud: Use private and public clouds interconnected Private Cloud: Cloud used by a single entity On premises Offers total control More cost and complexity Service Types: Cloud providers distinguish 3 types of service. Each service place responsibility to the provider or the customer side (Shared responsibility model). These are:
IaaS: Infrastructure as a service Most responsibility to the customer Provider maintains and manages physical infrastructure Examples include VM services, virtual networks, etc. PaaS Platform as a service Middleground Provider additionally maintains OS, dev tools, etc. Examples like Azure app services, AKS SaaS Software as a service Complete managed solution Examples include Managed dbs The different responsibilities for each service type are shown below
`,description:"",tags:null,title:"Cloud Concepts",uri:"/azure/cloudconcepts/index.html"},{content:`The key component of git is the commits. A commit is single point in the Git history; the entire history of a project is represented as a set of interrelated commits.
Good practice By good practice, commits should be atomic. This means each commit should relate to only one feature. This makes it easier to control, and roll back.
Commit Message A commit contains the current contents of the index and the given log message describing the changes.
The commit message should follow:
Is recommended by Git that the message is written in present tense + imperative Similar to giving orders to the machine Some examples: Fix bug in template code Make script compatible with centos Ammending Ammending a commit replaces the tip of the current branch by creating a new commit that starts from the last one.
In practice it can be used to “fix” the last commit.
Remember The changes to ammend need to be staged
Ignoring files and directories Files that should not bre tracked by git can be specified in a .gitignore file.
The file supports files, directories and also glob expressions to match several files at the same time.
More information can be seen in the https://git-scm.com/docs/gitignore
`,description:"",tags:null,title:"Commiting",uri:"/git/commiting/index.html"},{content:`Below are some of the most used commands when using git from the command line:
git init Initializes a git repository in the current directory. This is done by creating a hidden .git directory. Git docs If used with a name as an argument like git init example It will first create a folder called example and inside this folder initialize the repo.
Tip To make a directory not a git repository anymore, just delete the hidden .git folder.
git status Shows the current state of the files according to the basic workflow (un-tracked, staged). Git docs git add Normally used like git add file it adds a file to staging. This is done before committing because only staged files (or changes) are added to the commit.
Git docs
If used like
git add -A or
git add . Adds all the files that have been modified
git commit Allows to create a commit for the staged changes. Git docs To commit with a message directly:
git commit -m "message" Default editor If called without arguments, the command will prompt for a commit message using the default editor. This can be changed with git config --global core.editor More info here git log Retrieves a complete list of commit history for the repo
Its output can be compacted with the --oneline flag Git docs `,description:"",tags:null,title:"Basic Commands",uri:"/git/basic-commands/index.html"},{content:"",description:"",tags:null,title:"Categories",uri:"/categories/index.html"},{content:"",description:"",tags:null,title:"Tags",uri:"/tags/index.html"}]